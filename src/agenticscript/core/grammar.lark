// AgenticScript Grammar for Lark Parser
// Phase 2: Module imports, tool assignment, inter-agent communication

start: statement*

// Statements
statement: import_statement
         | agent_declaration
         | property_assignment
         | tool_assignment
         | assignment_statement
         | if_statement
         | print_statement
         | expression_statement

// Agent declarations: agent a = spawn Agent{ openai/gpt-4o }
agent_declaration: "agent" IDENTIFIER "=" "spawn" agent_constructor

agent_constructor: "Agent" "{" model_spec ("," config_pair)* "}"

model_spec: MODEL_PATH

config_pair: IDENTIFIER ":" value

// Import statements: import agenticscript.stdlib.tools { WebSearch, AgentRouting }
import_statement: "import" module_path "{" import_list "}"

module_path: IDENTIFIER ("." IDENTIFIER)*

import_list: IDENTIFIER ("," IDENTIFIER)*

// Property assignment: *b->goal = "Gives random reply"
property_assignment: "*" IDENTIFIER "->" IDENTIFIER "=" value

// Tool assignment: *a->tools = { WebSearch } or *a->tools += { Calculator }
tool_assignment: "*" IDENTIFIER "->" "tools" tool_operator tool_list

// Variable assignment: result = expression
assignment_statement: IDENTIFIER "=" expression

tool_operator: "=" | "+="

tool_list: "{" tool_spec ("," tool_spec)* "}"

tool_spec: IDENTIFIER
         | agent_routing

agent_routing: IDENTIFIER "{" identifier_list "}"

identifier_list: IDENTIFIER ("," IDENTIFIER)*

// If statements: if condition { statements } else { statements }
if_statement: "if" condition "{" statement* "}" ("else" "{" statement* "}")?

condition: boolean_expression

boolean_expression: comparison_expression
                  | boolean_expression "and" boolean_expression
                  | boolean_expression "or" boolean_expression
                  | "(" boolean_expression ")"

comparison_expression: expression comparison_operator expression
                     | method_call

comparison_operator: "==" | "!=" | "<" | ">" | "<=" | ">="

// Print statement: print(a.status)
print_statement: "print" "(" expression ")"

// Expression statement
expression_statement: expression

// Expressions
expression: property_access
          | method_call
          | value
          | IDENTIFIER

property_access: IDENTIFIER "." IDENTIFIER

method_call: IDENTIFIER "." IDENTIFIER "(" arguments? ")"

arguments: argument ("," argument)*

argument: value
        | IDENTIFIER "=" value  // Named arguments like timeout=30

// Values
value: string
     | f_string
     | number
     | boolean
     | list
     | dict

string: ESCAPED_STRING

f_string: F_STRING_START f_string_content* F_STRING_END

f_string_content: F_STRING_TEXT
                | "{" expression "}"
number: SIGNED_NUMBER
boolean: "true" | "false"

list: "[" (value ("," value)*)? "]"
dict: "{" (dict_pair ("," dict_pair)*)? "}"
dict_pair: (IDENTIFIER | string) ":" value

// Terminals
IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/
MODEL_PATH: /[a-zA-Z0-9_-]+\/[a-zA-Z0-9_.-]+/
ESCAPED_STRING: /\"([^\"\\]|\\.)*\"/

// F-string terminals
F_STRING_START: "f\""
F_STRING_END: "\""
F_STRING_TEXT: /[^{\"\\]+/

// Import common terminals
%import common.SIGNED_NUMBER
%import common.WS
%import common.NEWLINE

// Ignore whitespace and newlines
%ignore WS
%ignore NEWLINE